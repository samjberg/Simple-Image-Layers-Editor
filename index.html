<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- maximum-scale=1.0 and user-scalable=no to prevent page zooming -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simple Image Layers Editor</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#222222">
    <link rel="apple-touch-icon" href="icon-192.png">

    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use Inter font */
        body {
            font-family: 'Inter', sans-serif;
            /* Prevent pull-to-refresh and other touch behaviors */
            touch-action: none;
        }
        /* Custom scrollbar for the layer panel */
        #layer-panel-container::-webkit-scrollbar {
            width: 8px;
        }
        #layer-panel-container::-webkit-scrollbar-track {
            background: #f1f5f9; /* gray-100 */
        }
        #layer-panel-container::-webkit-scrollbar-thumb {
            background: #94a3b8; /* gray-400 */
            border-radius: 4px;
        }
        #layer-panel-container::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* gray-500 */
        }
        /* Style for the file input label */
        .file-input-btn {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        /* Make the canvas grabbable */
        #editor-canvas {
            cursor: grab;
            /* Critical for touch gestures on canvas */
            touch-action: none;
        }
        #editor-canvas.grabbing {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen overflow-hidden">

    <div class="relative h-full flex">

        <!-- ===== Mobile Menu Toggle Button ===== -->
        <button id="menu-toggle-btn" class="lg:hidden fixed top-4 left-4 z-50 p-2 bg-white rounded-full shadow-lg text-gray-700 hover:bg-gray-100">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
            </svg>
        </button>

        <!-- ===== Sidebar: Controls & Layers (Now a drawer on mobile) ===== -->
        <aside id="sidebar" class="w-80 bg-white shadow-lg flex flex-col fixed inset-y-0 left-0 z-40
                                  transform -translate-x-full lg:translate-x-0 lg:static
                                  transition-transform duration-300 ease-in-out">
            <!-- Header -->
            <div class="p-4 border-b flex justify-between items-center">
                <h1 class="text-xl font-bold text-gray-800">Quick Layer Editor</h1>
                <!-- Close button for mobile drawer -->
                <button id="menu-close-btn" class="lg:hidden text-gray-500 hover:text-gray-800">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <!-- Global Controls -->
            <div class="p-4 space-y-3 border-b">
                <!-- Add Image Button -->
                <label for="file-input" class="file-input-btn w-full text-center bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md block">
                    + Add Image Layer
                </label>
                <input type="file" id="file-input" class="hidden" accept="image/*">

                <!-- Export & Clear Buttons -->
                <div class="grid grid-cols-2 gap-2">
                    <button id="export-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg text-sm">
                        Export Image
                    </button>
                    <button id="clear-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-lg text-sm">
                        Clear All
                    </button>
                </div>
            </div>

            <!-- Layer Panel -->
            <div id="layer-panel-container" class="flex-1 p-4 space-y-3 overflow-y-auto">
                <h2 class="text-sm font-semibold text-gray-500 uppercase">Layers</h2>
                <!-- Layers will be dynamically added here in reverse order (top layer at the top) -->
                <div id="layer-panel" class="flex flex-col-reverse gap-3">
                    <!-- ... layers ... -->
                </div>
            </div>
        </aside>

        <!-- ===== Mobile Menu Overlay ===== -->
        <div id="menu-overlay" class="lg:hidden fixed inset-0 bg-black bg-opacity-50 z-30 hidden"></div>


        <!-- ===== Main Canvas Area ===== -->
        <main class="flex-1 flex items-center justify-center p-4 lg:p-8 bg-gray-200 overflow-hidden h-full">
            <canvas id="editor-canvas" class="bg-white rounded-lg shadow-xl max-w-full max-h-full"></canvas>
        </main>

    </div>

    <!-- ===== JavaScript Logic ===== -->
    <script type="module">
        // Get DOM Elements
        const canvas = document.getElementById('editor-canvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('file-input');
        const exportBtn = document.getElementById('export-btn');
        const clearBtn = document.getElementById('clear-btn');
        const layerPanel = document.getElementById('layer-panel');
        
        const sidebar = document.getElementById('sidebar');
        const menuToggleBtn = document.getElementById('menu-toggle-btn');
        const menuCloseBtn = document.getElementById('menu-close-btn');
        const menuOverlay = document.getElementById('menu-overlay');

        // Application State
        const appState = {
            layers: [],
            activeLayerId: null,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            dragStartLayerX: 0,
            dragStartLayerY: 0,
            canvasAspectRatio: 4 / 3, // Default aspect ratio
            
            // --- NEW: State for touch gestures ---
            isGesturing: false,
            gestureStartDist: 0,
            gestureStartAngle: 0,
            gestureStartScale: 1,
            gestureStartRotation: 0,
        };
        
        // --- Menu Drawer Logic ---
        function openMenu() {
            sidebar.classList.remove('-translate-x-full');
            menuOverlay.classList.remove('hidden');
        }

        function closeMenu() {
            sidebar.classList.add('-translate-x-full');
            menuOverlay.classList.add('hidden');
        }

        menuToggleBtn.addEventListener('click', openMenu);
        menuCloseBtn.addEventListener('click', closeMenu);
        menuOverlay.addEventListener('click', closeMenu);


        // --- Initialization ---
        function getContainerSize() {
            const canvasContainer = canvas.parentElement;
            const containerWidth = canvasContainer.clientWidth - 32; // p-4
            const containerHeight = canvasContainer.clientHeight - 32; // p-4
            
            const lgContainerWidth = canvasContainer.clientWidth - 64; // p-8
            const lgContainerHeight = canvasContainer.clientHeight - 64; // p-8

            const isLg = window.innerWidth >= 1024; // lg breakpoint
            const effectiveWidth = isLg ? lgContainerWidth : containerWidth;
            const effectiveHeight = isLg ? lgContainerHeight : containerHeight;
            
            return { width: effectiveWidth, height: effectiveHeight };
        }

        function initializeCanvas() {
            const { width: effectiveWidth, height: effectiveHeight } = getContainerSize();
            const ratio = appState.canvasAspectRatio;

            let canvasWidth, canvasHeight;
            if (effectiveWidth / ratio > effectiveHeight) {
                canvasHeight = effectiveHeight;
                canvasWidth = effectiveHeight * ratio;
            } else {
                canvasWidth = effectiveWidth;
                canvasHeight = effectiveWidth / ratio;
            }

            canvas.width = canvasWidth > 0 ? canvasWidth : 800;
            canvas.height = canvasHeight > 0 ? canvasHeight : 600;

            renderCanvas();
        }

        // --- Core Rendering ---
        function renderCanvas() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // --- FIXED (Issue 1): Draw a proper checkerboard pattern for transparency ---
            const checkerSize = 20;
            for (let y = 0; y < canvas.height; y += checkerSize) {
                for (let x = 0; x < canvas.width; x += checkerSize) {
                    // Set fillStyle based on position
                    if ((Math.floor(x / checkerSize) + Math.floor(y / checkerSize)) % 2 === 0) {
                        ctx.fillStyle = '#FFFFFF'; // White square
                    } else {
                        ctx.fillStyle = '#f0f0f0'; // Light gray square
                    }
                    ctx.fillRect(x, y, checkerSize, checkerSize);
                }
            }

            // Draw each layer from bottom (index 0) to top
            appState.layers.forEach(layer => {
                ctx.save(); // Save context state

                // Apply transformations
                ctx.globalAlpha = layer.opacity;

                // --- CHANGED (Issue 2b): Calculate final scale ---
                const finalScale = layer.baseScale * layer.userScale;

                // Translate to the layer's center
                ctx.translate(layer.x, layer.y);
                // Rotate around the center
                ctx.rotate(layer.rotation);
                // Scale from the center
                ctx.scale(finalScale, finalScale);

                // Draw the image centered on the transformed origin
                ctx.drawImage(
                    layer.image,
                    -layer.originalWidth / 2,
                    -layer.originalHeight / 2,
                    layer.originalWidth,
                    layer.originalHeight
                );

                ctx.restore(); // Restore context state for the next layer
            });

            // Draw bounding box for the active layer
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                ctx.save();
                
                // --- CHANGED (Issue 2b): Use final scale for bounding box ---
                const finalScale = activeLayer.baseScale * activeLayer.userScale;

                ctx.translate(activeLayer.x, activeLayer.y);
                ctx.rotate(activeLayer.rotation);
                ctx.scale(finalScale, finalScale);
                
                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 2 / finalScale; // Keep line width consistent
                ctx.strokeRect(
                    -activeLayer.originalWidth / 2,
                    -activeLayer.originalHeight / 2,
                    activeLayer.originalWidth,
                    activeLayer.originalHeight
                );
                
                ctx.restore();
            }
        }

        // --- UI Updates ---
        function updateLayerPanel() {
            layerPanel.innerHTML = ''; // Clear existing panel
            
            appState.layers.forEach(layer => {
                const isActive = layer.id === appState.activeLayerId;
                const layerEl = document.createElement('div');
                layerEl.className = `p-2 rounded-lg bg-white shadow-sm border-2 ${isActive ? 'border-blue-500' : 'border-transparent'}`;
                layerEl.setAttribute('data-id', layer.id);

                // --- MODIFIED: Removed Scale and Rotation sliders ---
                layerEl.innerHTML = `
                    <p class="font-medium text-gray-700 truncate text-sm" title="${layer.name}">${layer.name}</p>
                    <div class="mt-2 space-y-2">
                        <!-- Opacity -->
                        <div>
                            <label class="text-xs font-medium text-gray-500">Opacity</label>
                            <input type="range" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" min="0" max="1" step="0.01" value="${layer.opacity}" data-property="opacity">
                        </div>
                    </div>
                    <!-- Actions -->
                    <div class="mt-2 grid grid-cols-3 gap-1">
                        <button class="text-xs py-1 px-2 bg-gray-100 hover:bg-gray-200 rounded" data-action="move-up">▲ Up</button>
                        <button class="text-xs py-1 px-2 bg-gray-100 hover:bg-gray-200 rounded" data-action="move-down">▼ Down</button>
                        <button class="text-xs py-1 px-2 bg-red-100 hover:bg-red-200 text-red-700 rounded" data-action="delete">Delete</button>
                    </div>
                `;
                layerPanel.appendChild(layerEl);
            });
        }

        // --- Event Handlers ---

        // Handle New Image Upload
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {

                    // --- CHANGED (Issue 2a): Resize canvas if first image ---
                    if (appState.layers.length === 0) {
                        appState.canvasAspectRatio = img.width / img.height;
                        initializeCanvas(); // Resize canvas *before* calculating scale
                    }

                    // --- *** FIXED *** ---
                    // This is the fix for the "image is too big" problem.
                    // This logic correctly calculates the scale to fit the image
                    // within the canvas bounds, then applies the 75% sizing.
                    const widthScale = canvas.width / img.width;
                    const heightScale = canvas.height / img.height;
                    const baseScale = Math.min(widthScale, heightScale) * 0.75;
                    // --- *** END FIX *** ---

                    const newLayer = {
                        id: Date.now(),
                        name: file.name,
                        image: img,
                        originalWidth: img.width,
                        originalHeight: img.height,
                        x: canvas.width / 2, // Center new layer
                        y: canvas.height / 2,
                        baseScale: baseScale,  // Base scale to fit
                        userScale: 1,          // User-controlled scale (starts at 100%)
                        rotation: 0,
                        opacity: 1,
                    };
                    appState.layers.push(newLayer);
                    appState.activeLayerId = newLayer.id;
                    updateLayerPanel();
                    renderCanvas();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            
            e.target.value = null;
        });
        
        // Handle Layer Panel Clicks
        layerPanel.addEventListener('click', (e) => {
            const layerItem = e.target.closest('[data-id]');
            if (!layerItem) return;

            const id = Number(layerItem.dataset.id);
            const action = e.target.dataset.action;

            if (action) {
                handleLayerAction(id, action);
            } else {
                appState.activeLayerId = id;
                updateLayerPanel();
                renderCanvas();
            }

            if (!e.target.dataset.action && !e.target.closest('input')) {
                if (window.innerWidth < 1024) {
                    closeMenu();
                }
            }
        });
        
        // Handle Slider Inputs
        layerPanel.addEventListener('input', (e) => {
             const layerItem = e.target.closest('[data-id]');
             if (!layerItem || e.target.type !== 'range') return;

             const id = Number(layerItem.dataset.id);
             const property = e.target.dataset.property;
             const value = Number(e.target.value);

             const layer = findLayerById(id);
             if (layer) {
                layer[property] = value;
                renderCanvas();
             }
        });
        
        function handleLayerAction(id, action) {
            const index = appState.layers.findIndex(l => l.id === id);
            if (index === -1) return;

            switch (action) {
                case 'delete':
                    appState.layers.splice(index, 1);
                    if (appState.activeLayerId === id) {
                        appState.activeLayerId = null;
                    }
                    // --- CHANGED (Issue 2a): Reset aspect ratio if last layer deleted ---
                    if (appState.layers.length === 0) {
                        appState.canvasAspectRatio = 4 / 3; // Reset to default
                        initializeCanvas();
                    }
                    break;
                case 'move-up':
                    if (index < appState.layers.length - 1) {
                        [appState.layers[index], appState.layers[index + 1]] = [appState.layers[index + 1], appState.layers[index]];
                    }
                    break;
                case 'move-down':
                    if (index > 0) {
                        [appState.layers[index], appState.layers[index - 1]] = [appState.layers[index - 1], appState.layers[index]];
                    }
                    break;
            }
            updateLayerPanel();
            renderCanvas();
        }

        // --- Canvas Drag Handlers (Mouse & Touch) ---
        
        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            if (e.touches) {
                if (e.touches.length > 0) {
                    x = e.touches[0].clientX;
                    y = e.touches[0].clientY;
                } else {
                    return null; 
                }
            } else {
                x = e.clientX;
                y = e.clientY;
            }
            return {
                x: x - rect.left,
                y: y - rect.top
            };
        }

        function isPointInLayer(x, y, layer) {
            // --- CHANGED (Issue 2b): Use final scale for hit detection ---
            const finalScale = layer.baseScale * layer.userScale;

            const dx = x - layer.x;
            const dy = y - layer.y;
            
            const cos = Math.cos(-layer.rotation);
            const sin = Math.sin(-layer.rotation);
            const rx = dx * cos - dy * sin;
            const ry = dx * sin + dy * cos;
            
            const ux = rx / finalScale;
            const uy = ry / finalScale;
            
            const halfW = layer.originalWidth / 2;
            const halfH = layer.originalHeight / 2;
            
            return ux >= -halfW && ux <= halfW && uy >= -halfH && uy <= halfH;
        }

        // --- MODIFIED: Renamed to handleStart for clarity ---
        function handleStart(e) {
            // Prevent default touch behaviors like scrolling
            if (e.touches) {
                e.preventDefault();
            }
            
            // --- Handle multi-touch gesture (scale/rotate) ---
            if (e.touches && e.touches.length === 2) {
                const activeLayer = getActiveLayer();
                if (!activeLayer) return; // Need an active layer to gesture

                appState.isDragging = false; // Stop any dragging
                appState.isGesturing = true;
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];

                // Calculate initial distance and angle
                appState.gestureStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                appState.gestureStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
                
                // Store initial layer state
                appState.gestureStartScale = activeLayer.userScale;
                appState.gestureStartRotation = activeLayer.rotation;
                return;
            }

            // --- Handle single-touch drag (or mouse drag) ---
            if (e.touches && e.touches.length > 1) return; // Ignore if more than 2 touches or switching
            if (e.button && e.button !== 0) return; // Ignore right-clicks

            const coords = getEventCoords(e);
            if (!coords) return;
            
            const activeLayer = getActiveLayer();
            let layerClicked = false;
            if (activeLayer && isPointInLayer(coords.x, coords.y, activeLayer)) {
                 layerClicked = true; 
            } else {
                let newActiveLayer = null;
                for (let i = appState.layers.length - 1; i >= 0; i--) {
                    const layer = appState.layers[i];
                    if (isPointInLayer(coords.x, coords.y, layer)) {
                        newActiveLayer = layer;
                        break;
                    }
                }
                
                if (newActiveLayer) {
                    appState.activeLayerId = newActiveLayer.id;
                    updateLayerPanel(); 
                    renderCanvas();
                    layerClicked = true;
                } else {
                    appState.activeLayerId = null;
                    updateLayerPanel();
                    renderCanvas();
                    return; 
                }
            }

            if (layerClicked) {
                const layerToDrag = getActiveLayer();
                appState.isDragging = true;
                appState.isGesturing = false; // Ensure gesture is off
                canvas.classList.add('grabbing');
                appState.dragStartX = coords.x;
                appState.dragStartY = coords.y;
                appState.dragStartLayerX = layerToDrag.x;
                appState.dragStartLayerY = layerToDrag.y;
            }
        }

        // --- MODIFIED: Renamed to handleMove for clarity ---
        function handleMove(e) {
            // --- Handle multi-touch gesture ---
            if (e.touches && e.touches.length === 2 && appState.isGesturing) {
                e.preventDefault();
                const activeLayer = getActiveLayer();
                if (!activeLayer) return;

                const t1 = e.touches[0];
                const t2 = e.touches[1];

                // --- Scale Logic ---
                const currentDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                const scaleDelta = currentDist / appState.gestureStartDist;
                activeLayer.userScale = appState.gestureStartScale * scaleDelta;
                
                // --- Rotation Logic ---
                const currentAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
                const angleDelta = currentAngle - appState.gestureStartAngle;
                activeLayer.rotation = appState.gestureStartRotation + angleDelta;

                renderCanvas();
                return;
            }

            // --- Handle single-touch drag ---
            if (appState.isDragging && (!e.touches || e.touches.length === 1)) {
                e.preventDefault();
                const coords = getEventCoords(e);
                if (!coords) return;
                const activeLayer = getActiveLayer();
                if (!activeLayer) return;

                const deltaX = coords.x - appState.dragStartX;
                const deltaY = coords.y - appState.dragStartY;

                activeLayer.x = appState.dragStartLayerX + deltaX;
                activeLayer.y = appState.dragStartLayerY + deltaY;

                renderCanvas();
            }
        }

        // --- MODIFIED: Renamed to handleEnd for clarity ---
        function handleEnd(e) {
            // Check remaining touches
            const remainingTouches = e.touches ? e.touches.length : 0;

            if (remainingTouches < 2) {
                appState.isGesturing = false;
            }
            
            if (remainingTouches < 1) {
                appState.isDragging = false;
                canvas.classList.remove('grabbing');
            }
        }

        // Mouse events
        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        // Touch events
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('touchend', handleEnd);
        window.addEventListener('touchcancel', handleEnd);


        // --- Global Actions ---
        
        exportBtn.addEventListener('click', () => {
            const currentActiveId = appState.activeLayerId;
            appState.activeLayerId = null;
            renderCanvas(); 

            const dataUrl = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = dataUrl;
            link.click();

            appState.activeLayerId = currentActiveId;
            renderCanvas();
        });

        clearBtn.addEventListener('click', () => {
            appState.layers = [];
            appState.activeLayerId = null;
            // --- CHANGED (Issue 2a): Reset aspect ratio on clear ---
            appState.canvasAspectRatio = 4 / 3;
            initializeCanvas(); // Re-initializes canvas with default ratio
            updateLayerPanel();
        });

        // --- Helper Functions ---
        function findLayerById(id) {
            return appState.layers.find(l => l.id === id);
        }
        function getActiveLayer() {
            if (!appState.activeLayerId) return null;
            return findLayerById(appState.activeLayerId);
        }

        // --- Start ---
        initializeCanvas();
        
        // Re-initialize canvas on resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                // Save layer positions as ratios
                const oldW = canvas.width;
                const oldH = canvas.height;
                appState.layers.forEach(l => {
                    l.xRatio = l.x / oldW;
                    l.yRatio = l.y / oldH;
                });
                
                initializeCanvas(); // This resizes canvas
                
                // Restore layer positions
                appState.layers.forEach(l => {
                    l.x = (l.xRatio || 0.5) * canvas.width;
                    l.y = (l.yRatio || 0.5) * canvas.height;
                    delete l.xRatio;
                    delete l.yRatio;
                });
                renderCanvas();

            }, 250);
        });

    </script>

    <script>
        // register service worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js')
                .then((reg) => {
                console.log('Service worker registered.', reg);
                })
                .catch((err) => {
                console.error('Service worker registration failed:', err);
                });
            });
        }
    </script>

</body>
</html>